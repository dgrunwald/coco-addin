/*---------------------------------------------------------------------------*\
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
-------------------------------------------------------------------------------
License
    This file is part of Compiler Generator Coco/R

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.

About this file
    This is a so-called 'frame' file that contains skeleton code for
    generating a final Scanner/Parser code.

    The '-->TAG' text markers are used to delimit code chunks and typically
    correspond to places where additional information is added by the
    DFA or ParserGen code.

    All information prior to the first 'begin' text marker is discarded.
    If the grammar contains a '[copy]' .. '[/copy]' section, its contents
    will added instead.
\*---------------------------------------------------------------------------*/
-->begin
using System;
using System.Collections;

-->namespace

// ----------------------------------------------------------------------------
// Parser
// ----------------------------------------------------------------------------
//! A Coco/R Parser
public partial class Parser
{
-->constants
	const bool T = true;
	const bool x = false;
	const int minErrDist = 2;

	public Scanner scanner;
	public Errors  errors;

	public Token t;    //!< last recognized token
	public Token la;   //!< lookahead token
	int errDist = minErrDist;

-->declarations

	public Parser(Scanner scanner) {
		this.scanner = scanner;
		errors = new Errors();
	}

	void SynErr (int n) {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public void SemErr (string msg) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}

	void Get () {
		for (;;) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
			la = t;
		}
	}

	void Expect (int n) {
		if (la.kind==n) Get(); else { SynErr(n); }
	}

	bool StartOf (int s) {
		return set[s].Get(la.kind);
	}

	void ExpectWeak (int n, int follow) {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}


	bool WeakSeparator(int n, int syFol, int repFol) {
		int kind = la.kind;
		if (kind == n) {Get(); return true;}
		else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(set[syFol].Get(kind) || set[repFol].Get(kind) || set[0].Get(kind))) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}


-->productions

	public void Parse() {
		la = new Token();
		la.val = "";
		Get();
-->parseRoot
	}

	static readonly BitArray[] set = {
-->initialization
	};
} // end Parser


//-----------------------------------------------------------------------------
// Errors
//-----------------------------------------------------------------------------
//! Parser error handling
public class Errors
{
	public int count = 0;                                    // number of errors detected
	public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
	public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

	static string strerror(int n) {
		switch (n) {
-->errors
			default: return "error " + n;
		}
	}

	public void SynErr (int line, int col, int n) {
		WriteError(line, col, strerror(n));
	}

	public void SemErr (int line, int col, string s) {
		WriteError(line, col, s);
	}

	public void SemErr (string s) {
		WriteError(0, 0, s);
	}

	public virtual void Warning (int line, int col, string s) {
		errorStream.WriteLine(errMsgFormat, line, col, s);
	}

	public virtual void Warning(string s) {
		errorStream.WriteLine(s);
	}
	
	public virtual void WriteError(int line, int col, string message) {
		if (line > 0)
			errorStream.WriteLine(errMsgFormat, line, col, message);
		else
			errorStream.WriteLine(message);
		count++;
	}
} // Errors


//-----------------------------------------------------------------------------
// FatalError
//-----------------------------------------------------------------------------
//! Parser fatal error handling
public class FatalError: Exception {
	public FatalError(string m): base(m) {}
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

$$$
