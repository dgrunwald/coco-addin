/*---------------------------------------------------------------------------*\
    Coco-cs.atg -- Attributed Grammar for Coco/R C# version
    compile with:
        coco-cs Coco-cs.atg
\*---------------------------------------------------------------------------*/
[copy]
/*---------------------------------------------------------------------------*\
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
-------------------------------------------------------------------------------
License
    This file is part of Compiler Generator Coco/R

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
\*---------------------------------------------------------------------------*/
[/copy]

using System.IO;
using System.Collections.Generic;
using ICSharpCode.AvalonEdit.Document;

COMPILER SimpleCoco
/*-------------------------------------------------------------------------*/

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable = '\u0020' .. '\u007e'.
    hex       = "0123456789abcdef".

TOKENS
    ident     = letter { letter | digit }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
    ddtSym    = '$' { digit | letter }.  
    directive = '$' letter { letter } '='
        { digit | letter | '-' | '.' | ':' | '/' | '\\' } .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

SimpleCoco
=
  (. parserName = "DummyParser"; .)
  // copyrights, notices, comments, etc. to add to the generated files
  [ "[copy]" (. copySection = new TextSegment() { StartOffset = t.pos }; .)
    { ANY }
    "[/copy]" (. copySection.EndOffset = t.pos + t.val.Length; .)
  ]

  [ // using statements
    ANY (. usingSection = new TextSegment() { StartOffset = t.pos }; .)
    { ANY } (. usingSection.EndOffset = t.pos + 1; .)
  ]
  (. parserSection = new TextSegment() { StartOffset = la.pos }; .)
  ( 
    "COMPILER"
  | "PUSHCOMPILER"
    { "WITH"
      ( "EXPECTEDSETS" )
    }
  )
  ident (. parserName = t.val; .)

  // semantic declarations - ie, class members and methods
  [ ANY
    { ANY }
  ]

  [ "IGNORECASE" ]   /* pdt */
  [ (. ListInfo chars = new ListInfo() {
  	name = "CHARACTERS",
  	segment = new TextSegment() { StartOffset = la.pos }
}; .)
  "CHARACTERS" { SetDecl }
  (. chars.segment.EndOffset = t.pos + (t.val != null  ? t.val.Length : 1); lists.Add(chars); .)
]
  [ (. ListInfo toks = new ListInfo() {
  	name = "TOKENS",
  	segment = new TextSegment() { StartOffset = la.pos }
}; .)
  "TOKENS" { TokenDecl }
    (. toks.segment.EndOffset = t.pos + (t.val != null  ? t.val.Length : 1); lists.Add(toks); .)
  ]
  [ (. ListInfo prags = new ListInfo() {
  	name = "PRAGMAS",
  	segment = new TextSegment() { StartOffset = la.pos }
}; .)
  "PRAGMAS" { TokenDecl }
  (. prags.segment.EndOffset = t.pos + (t.val != null  ? t.val.Length : 1); lists.Add(prags); .)
  ]
  { "COMMENTS"      
    "FROM" TokenExpr
    "TO" TokenExpr
    [ "NESTED"
    ]
  }
  { "IGNORE" Set
  }

  SYNC
  "PRODUCTIONS"
  { (. ListInfo prod = new ListInfo() {
  	name = la.val,
  	segment = new TextSegment() { StartOffset = la.pos }
}; .)
  ident 
    [ AttrDecl ] 
    [ SemText ] WEAK
    '='
    Expression      
                            WEAK
    '.' (. prod.segment.EndOffset = t.pos + (t.val != null  ? t.val.Length : 1); productions.Add(prod); .)
  }
  "END" ident '.' (. parserSection.EndOffset = t.pos + 1; .)
.

/*------------------------------------------------------------------------------------*/

SetDecl    
=
  ident                 
  '=' Set         
  '.'
.

/*------------------------------------------------------------------------------------*/

Set
=
  SimSet
  { '+' SimSet         
  | '-' SimSet      
  }
.

/*------------------------------------------------------------------------------------*/

SimSet =
( ident                 
| string                  
| Char   
  [ ".." Char
  ]
| "ANY"       
)
.

/*--------------------------------------------------------------------------------------*/

Char = char .

/*------------------------------------------------------------------------------------*/

TokenDecl
=
  Sym
  SYNC
  [ '=' TokenExpr '.' ]
  [ SemText ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl
=
  '<'                       
  { ANY
  | badString                
  }
  '>'                     
| "<."                      
  { ANY
  | badString                  
  }
  ".>"                       
.

/*------------------------------------------------------------------------------------*/

Expression     
=
  Term          
  {                             WEAK
    '|'
    Term       
  }
.

/*------------------------------------------------------------------------------------*/

Term      
=
( [                             
    Resolver   
  |                             
    ExpectedConflict 
  ]
  Factor           
  { Factor          
  }
|                               
)                         
.

/*------------------------------------------------------------------------------------*/

Factor
=
( [ "WEAK"                       ]
  [ "GREEDY"                     ]
  Sym
  [ Attribs                  
  ]                         
| '(' Expression ')'
| '['                            
   Expression             
   ']'
| '{'                            
  Expression             
  '}'
| SemText         
| "ANY"                   
| "SYNC"                     
)                          
.

/*------------------------------------------------------------------------------------*/

Resolver
=
  "IF" "("                       
  Condition                      
.

ExpectedConflict

=
  "EXPECTEDCONFLICT" "(" 
  ConflictSymbol
  { ","
    ConflictSymbol
  }
  ")" 
.

ConflictSymbol

=
    Sym
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr
=
  TokenTerm
  {                             WEAK
    '|'
    TokenTerm
  }
.

/*---------------------------------------------------------------------------------a---*/

TokenTerm   
=
  TokenFactor
  { TokenFactor
  }
  [ "CONTEXT"
    '(' TokenExpr
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor
=
( Sym
| '(' TokenExpr ')'
| '[' TokenExpr ']'      
| '{' TokenExpr '}'      
)                            
.

/*------------------------------------------------------------------------------------*/

Sym
=                               
( ident                         
| (string                       
  | char                        
  )                   
)
.

/*------------------------------------------------------------------------------------*/

Attribs
=
  '<'                           
  { ANY
  | badString                   
  }
  '>'                           
| "<."                          
  { ANY
  | badString                   
  }
  ".>"                          
.

/*------------------------------------------------------------------------------------*/

SemText
=
  "(."
  { ANY
  | badString                   
  | "(."
  }
  ".)"                          
.

/*------------------------------------------------------------------------------------*/

END SimpleCoco.
